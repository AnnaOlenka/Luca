ONBOARDING MODAL - USER FLOW COMPLETO (ACTUALIZADO 2024)
==========================================================

```mermaid
graph TB
    %% INICIO DEL FLUJO
    Start([Usuario hace click en botón]) --> CheckModal{Modal OnboardingModal abierto?}
    
    CheckModal -->|Sí| LoadState[useOnboarding.getInitialState]
    CheckModal -->|No| End([Fin])
    
    %% INICIALIZACIÓN DEL ESTADO
    LoadState --> CheckLocalStorage{localStorage 'luca-tour-shown' existe?}
    CheckLocalStorage -->|Sí| SetHasShownTour[hasShownTour = true]
    CheckLocalStorage -->|No| SetHasNotShownTour[hasShownTour = false]
    
    SetHasShownTour --> InitialState[Estado inicial con hasShownTour: true]
    SetHasNotShownTour --> InitialState2[Estado inicial con hasShownTour: false]
    
    %% RENDERIZADO DEL MODAL
    InitialState --> RenderModal[OnboardingModal se renderiza]
    InitialState2 --> RenderModal
    
    %% LÓGICA DEL TOUR (useEffect)
    RenderModal --> TourCheck{Condiciones del tour:<br/>isOpen && !tourSkipped &&<br/>!hasShownTour && validCompanyCount === 0<br/>!showTourFloating}
    
    TourCheck -->|Todas cumplen| InitializeTour[actions.initializeTour()]
    TourCheck -->|No cumple| ShowModal[Mostrar modal sin tour]
    
    %% INICIALIZACIÓN DEL TOUR
    InitializeTour --> SaveTourFlag[localStorage.setItem('luca-tour-shown', 'true')]
    SaveTourFlag --> CreateFirstCompany[Crear primera empresa si no existe]
    CreateFirstCompany --> SetTourState[tourState: showTourFloating: true, tourStep: 1, hasShownTour: true]
    SetTourState --> ShowTourStep1[TourFloating renderiza Step 1]
    
    %% TOUR STEP 1
    ShowTourStep1 --> TourStep1{Usuario en TourFloating Step 1}
    TourStep1 -->|Click Continuar| HandleTourContinue[handleTourContinue()]
    TourStep1 -->|Click Omitir| HandleTourSkip[handleTourSkip()]
    TourStep1 -->|Click Cerrar X| HandleTourClose[handleTourClose()]
    
    %% CONTINUAR TOUR
    HandleTourContinue --> SetStep2[tourStep: 2, userClickedContinue: true]
    SetStep2 --> FocusRUC[setTimeout: buscar input RUC y hacer focus]
    FocusRUC --> ShowTourStep2[TourFloating renderiza Step 2]
    
    %% OMITIR O CERRAR TOUR
    HandleTourSkip --> SaveSkipFlag[localStorage.setItem('luca-tour-shown', 'true')]
    HandleTourClose --> SaveCloseFlag[localStorage.setItem('luca-tour-shown', 'true')]
    SaveSkipFlag --> HideTour[showTourFloating: false, tourSkipped: true]
    SaveCloseFlag --> HideTour
    HideTour --> ShowModal
    
    %% MODAL SIN TOUR O DESPUÉS DE OMITIR
    ShowModal --> CheckCompanies{state.companies.length === 0?}
    CheckCompanies -->|Sí| ShowEmptyState[Renderizar estado vacío:<br/>Sin empresas para mostrar]
    CheckCompanies -->|No| ShowCompaniesList[Renderizar lista de empresas<br/>CompanyAccordionItem por cada empresa]
    
    %% AGREGAR NUEVA EMPRESA
    ShowEmptyState --> AddCompanyBtn[Usuario hace click en 'Agregar Nueva Empresa']
    ShowCompaniesList --> AddCompanyBtn2[Usuario hace click en 'Agregar Nueva Empresa']
    AddCompanyBtn --> AddNewCompany[actions.addNewCompany()]
    AddCompanyBtn2 --> AddNewCompany
    
    AddNewCompany --> CreateCompany[Crear nueva CompanyData con ID único]
    CreateCompany --> CollapseOthers[Colapsar todas las empresas existentes]
    CollapseOthers --> AddToList[Agregar nueva empresa a la lista]
    AddToList --> CheckScroll{Lista >= 6 empresas?}
    CheckScroll -->|Sí| AutoScroll[setTimeout: scroll suave al final]
    CheckScroll -->|No| RenderCompanyItem[CompanyAccordionItem se renderiza expandido]
    AutoScroll --> RenderCompanyItem
    
    %% TOUR STEP 2 + VALIDACIÓN
    ShowTourStep2 --> UserInputRUC[Usuario comienza a escribir en campo RUC]
    RenderCompanyItem --> UserInputRUC2[Usuario escribe en campo RUC]
    
    %% VALIDACIÓN RUC EN TIEMPO REAL
    UserInputRUC --> HandleFieldChange[handleFieldChange('ruc', value)]
    UserInputRUC2 --> HandleFieldChange
    HandleFieldChange --> ValidateRucRealTime[validateRucRealTime(value)]
    
    ValidateRucRealTime --> CheckRucLength{value.length}
    CheckRucLength -->|0| SetRucNull[realTimeValidation.ruc = null]
    CheckRucLength -->|< 11 && !digits only| SetRucError[realTimeValidation.ruc = 'El RUC debe contener solo números']
    CheckRucLength -->|< 11 && digits only| SetRucIncomplete[realTimeValidation.ruc = 'El RUC debe tener 11 dígitos']
    CheckRucLength -->|== 11| ClearRucError[realTimeValidation.ruc = null]
    
    ClearRucError --> TriggerRucValidation[setTimeout: onValidate('ruc', value), 100ms]
    TriggerRucValidation --> ValidateCompanyRuc[validateCompany('ruc')]
    
    %% VALIDACIÓN RUC EN SERVIDOR (ACTUALIZADA CON ERROR_CONEXION)
    ValidateCompanyRuc --> SetValidating[validationState.ruc = 'validating', status = 'validando']
    SetValidating --> DelayValidation[setTimeout 1500ms]
    DelayValidation --> CheckRucInData{validateRuc: buscar en validCredentials.json}
    
    CheckRucInData -->|No encontrado| SetInvalid[validationState.ruc = 'invalid', status = 'no_valido']
    CheckRucInData -->|Duplicado| SetDuplicate[validationState.ruc = 'duplicate', status = 'no_valido']
    CheckRucInData -->|Error conexión RUC| SetRucErrorConexion[validationState.ruc = 'error_conexion', status = 'error_conexion']
    CheckRucInData -->|Inactivo| SetInactive[validationState.ruc = 'inactive', businessName actualizado]
    CheckRucInData -->|Válido| SetValid[validationState.ruc = 'valid', businessName actualizado]
    
    %% MANEJO DE ERROR DE CONEXIÓN EN RUC
    SetRucErrorConexion --> ClearCredentialsOnRucError[validationState.credentials = null]
    ClearCredentialsOnRucError --> UpdateStateErrorRuc[status = 'error_conexion', isValid = false, expanded = true]
    UpdateStateErrorRuc --> RenderMultipleLabelsRuc[Renderizar múltiples etiquetas:<br/>- 'En Proceso: Error de conexión en RUC'<br/>- Etiquetas de credenciales incompletas]
    
    %% DESPUÉS DE VALIDACIÓN RUC EXITOSA
    SetInvalid --> UpdateState[Actualizar estado con validationState]
    SetDuplicate --> UpdateState
    SetInactive --> CheckCredentialsExist{solUser && solPassword existen?}
    SetValid --> CheckCredentialsExist
    
    CheckCredentialsExist -->|Sí| AutoValidateCredentials[validateCredentials automáticamente]
    CheckCredentialsExist -->|No| UpdateState
    
    %% VALIDACIÓN DE CREDENCIALES (ACTUALIZADA)
    AutoValidateCredentials --> CheckCredsInData{Buscar en validCredentials.json<br/>SOLO SI RUC es válido/inactivo}
    CheckCredsInData -->|Error conexión credenciales| SetCredsErrorConexion[validationState.credentials = 'error_conexion']
    CheckCredsInData -->|Válidas| SetCredsValid[validationState.credentials = 'valid']
    CheckCredsInData -->|Inválidas| SetCredsInvalid[validationState.credentials = 'invalid']
    
    %% USUARIO INGRESA CREDENCIALES MANUALMENTE
    UpdateState --> UserInputCredentials[Usuario escribe en Usuario SOL/Contraseña]
    UserInputCredentials --> HandleCredsChange[handleFieldChange('solUser'/'solPassword')]
    
    HandleCredsChange --> CheckFieldEmpty{Campo vacío?}
    CheckFieldEmpty -->|Sí| ClearCredValidation[onValidate('clearCredentials')]
    CheckFieldEmpty -->|No| CheckRucValidForCreds{validationState.ruc === 'valid' || 'inactive'?}
    
    CheckRucValidForCreds -->|No| NoValidation[No validar credenciales<br/>RUC debe ser válido primero]
    CheckRucValidForCreds -->|Sí| CheckBothFields{solUser && solPassword completos?}
    CheckBothFields -->|No| NoValidation
    CheckBothFields -->|Sí| ValidateCredentials[setTimeout: onValidate('credentials'), 100ms]
    
    ValidateCredentials --> SetCredsValidating[validationState.credentials = 'validating']
    SetCredsValidating --> DelayCredsValidation[setTimeout 1500ms]
    DelayCredsValidation --> CheckCredsInData
    
    %% DETERMINACIÓN DE ESTADO FINAL (ACTUALIZADA)
    SetCredsValid --> DetermineStatus[Determinar estado final de empresa]
    SetCredsInvalid --> DetermineStatus
    SetCredsErrorConexion --> DetermineStatus
    NoValidation --> DetermineStatus
    
    DetermineStatus --> CheckFinalStatus{Lógica de priorización ACTUALIZADA}
    CheckFinalStatus -->|Error conexión RUC o credenciales| SetStatusErrorConexion[status = 'error_conexion']
    CheckFinalStatus -->|RUC errors o < 11 dígitos| SetStatusInvalid[status = 'no_valido']
    CheckFinalStatus -->|Credenciales incorrectas| SetStatusInvalid
    CheckFinalStatus -->|RUC válido + credenciales válidas| SetStatusVerified[status = 'verificada', isValid = true, expanded = false]
    CheckFinalStatus -->|Campos vacíos sin errores| SetStatusIncomplete[status = 'incompleto']
    
    %% RENDERIZADO DE MÚLTIPLES ETIQUETAS (NUEVO)
    SetStatusErrorConexion --> RenderMultipleLabels[getDescriptiveStatusMessages()<br/>Renderizar etiquetas múltiples]
    RenderMultipleLabels --> CheckErrorType{Tipo de error de conexión}
    
    CheckErrorType -->|RUC válido + error credenciales| ShowRucValidAndCredsError[- 'Validado: RUC válido' (verde)<br/>- 'En Proceso: Error de conexión en credenciales' (naranja)]
    CheckErrorType -->|Error conexión RUC + credenciales incompletas| ShowRucErrorAndIncomplete[- 'En Proceso: Error de conexión en RUC' (naranja)<br/>- 'Incompleto: Credenciales vacías/Usuario vacío/Contraseña vacía' (amarillo)]
    
    %% CONTEO DE EMPRESAS VERIFICADAS
    SetStatusVerified --> RecalculateCount[newValidCount = empresas.filter(c => c.isValid).length]
    SetStatusInvalid --> RecalculateCount
    SetStatusIncomplete --> RecalculateCount
    ShowRucValidAndCredsError --> RecalculateCount
    ShowRucErrorAndIncomplete --> RecalculateCount
    
    %% LÓGICA DEL TOUR STEP 3
    RecalculateCount --> CheckTourStep3{newValidCount >= 1 &&<br/>showTourFloating &&<br/>tourStep === 2?}
    CheckTourStep3 -->|Sí| AdvanceToStep3[tourStep = 3, log 'Tour: Advancing to step 3']
    CheckTourStep3 -->|No| UpdateUI[Actualizar UI con nuevo estado]
    
    AdvanceToStep3 --> ShowTourStep3[TourFloating renderiza Step 3: '¡Excelente trabajo!']
    ShowTourStep3 --> AutoCloseTimer[useEffect: setTimeout 5000ms para cerrar tour]
    AutoCloseTimer --> AutoCloseTour[onClose() - handleTourClose]
    AutoCloseTour --> SaveCloseFlag
    
    %% RENDERIZADO VISUAL ACTUALIZADO
    UpdateUI --> RenderValidationVisuals[Renderizar indicadores visuales ACTUALIZADOS]
    RenderValidationVisuals --> ShowBordersUpdated[Colores de borde según validationState:<br/>- valid: verde<br/>- invalid/duplicate: rojo<br/>- inactive: amarillo<br/>- validating: azul<br/>- error_conexion: naranja]
    
    ShowBordersUpdated --> ShowIconsUpdated[Iconos de validación:<br/>- CheckCircle (verde): valid<br/>- XCircle (rojo): invalid/duplicate<br/>- AlertCircle (amarillo): inactive<br/>- Clock (azul, spinning): validating<br/>- AlertTriangle (naranja): error_conexion]
    
    ShowIconsUpdated --> ShowMessagesUpdated[Mensajes debajo de inputs:<br/>- RUC: 'Error de conexión en RUC'<br/>- Credenciales: 'Error de conexión en credenciales']
    
    ShowMessagesUpdated --> ShowStatusBadges[Badges de estado en header:<br/>- 'Validado: RUC válido' (verde)<br/>- 'Validado: RUC y credenciales validadas' (verde)<br/>- 'En Proceso: Error de conexión en RUC' (naranja)<br/>- 'En Proceso: Error de conexión en credenciales' (naranja)<br/>- 'Inválido: RUC inválido/credenciales inválidas' (rojo)<br/>- 'Incompleto: RUC/credenciales vacías' (amarillo)<br/>- 'Validando...' (azul)]
    
    ShowStatusBadges --> ShowBusinessName[Mostrar razón social si RUC válido/inactivo/error_conexion]
    ShowBusinessName --> ShowSunatInfo[Mostrar estado y condición SUNAT si disponible]
    
    %% ACCIONES DEL USUARIO EN LA EMPRESA
    ShowSunatInfo --> UserActions{Acciones disponibles}
    UserActions -->|Click accordion header| ExpandCollapse[expandCompany: toggle expanded state]
    UserActions -->|Click eliminar empresa| DeleteCompany[deleteCompany: filtrar empresa del array]
    UserActions -->|Modificar campos| HandleFieldChange
    
    %% ACCIONES DEL MODAL
    UserActions --> ModalActions{Acciones del modal}
    ModalActions -->|Click 'Ir a la Bandeja'| HandleBandejaClick[onNavigateToBandeja()]
    ModalActions -->|Click X cerrar modal| HandleModalClose[Confirmar guardar borrador?]
    ModalActions -->|Click fuera modal| HandleModalClose
    
    HandleModalClose --> ConfirmSave{state.companies.length > 0?}
    ConfirmSave -->|Sí| AskSaveDraft[window.confirm: '¿Deseas guardar como borrador?']
    ConfirmSave -->|No| CloseModal[onClose()]
    
    AskSaveDraft -->|Sí| SaveDraft[actions.saveDraft: guardar en localStorage]
    AskSaveDraft -->|No| CloseModal
    SaveDraft --> CloseModal
    
    CloseModal --> ClearTimers[actions.clearAllTimers()]
    ClearTimers --> End
    
    HandleBandejaClick --> CloseModal
    
    %% COMPONENTES INVOLUCRADOS
    classDef component fill:#e1f5fe
    classDef action fill:#f3e5f5
    classDef validation fill:#e8f5e8
    classDef storage fill:#fff3e0
    classDef tour fill:#fce4ec
    classDef error fill:#ffebee
    classDef success fill:#e8f5e8
    classDef warning fill:#fff8e1
    classDef info fill:#e3f2fd
    
    class OnboardingModal,CompanyAccordionItem,TourFloating,useOnboarding component
    class HandleFieldChange,AddNewCompany,ValidateCompany,HandleTourContinue action
    class ValidateRucRealTime,CheckRucInData,CheckCredsInData,DetermineStatus validation
    class SaveTourFlag,SaveDraft,CheckLocalStorage storage
    class InitializeTour,ShowTourStep1,ShowTourStep2,ShowTourStep3 tour
    class SetRucErrorConexion,SetCredsErrorConexion,ShowRucErrorAndIncomplete error
    class SetStatusVerified,ShowRucValidAndCredsError success
    class SetStatusIncomplete,ShowBusinessName warning
    class SetValidating,ShowMessagesUpdated info
```

COMPONENTES PRINCIPALES Y SUS RESPONSABILIDADES (ACTUALIZADAS):
===============================================================

## 1. OnboardingModal.tsx
- **Renderizado**: Modal principal, header, footer, estado vacío
- **Lógica del Tour**: useEffect para inicializar tour en primera apertura
- **Gestión de Estado**: Consume useOnboarding hook
- **Interacciones**: Cerrar modal, navegar a bandeja, agregar empresa
- **Props**: isOpen, onClose, onNavigateToBandeja

## 2. CompanyAccordionItem.tsx (ACTUALIZADO)
- **Renderizado**: Acordeón individual de empresa, inputs, validaciones visuales
- **Validación en Tiempo Real**: validateRucRealTime, validateSolUserRealTime, validateSolPasswordRealTime
- **Gestión de Focus**: Auto-focus en RUC, scroll suave
- **Estados Visuales**: Colores de borde (incluye naranja para error_conexion), iconos (incluye AlertTriangle), mensajes, badges de estado
- **Múltiples Etiquetas**: getDescriptiveStatusMessages() puede retornar múltiples etiquetas simultáneamente
- **Etiquetas Específicas**: 
  - "Validado: RUC válido" (verde)
  - "En Proceso: Error de conexión en RUC" (naranja) 
  - "En Proceso: Error de conexión en credenciales" (naranja)
  - "Incompleto: Usuario vacío/Contraseña vacía/Credenciales vacías" (amarillo)
  - "Inválido: RUC inválido/credenciales inválidas" (rojo)
- **Props**: company, onUpdate, onValidate, onDelete, onExpand
- **Estado Local**: realTimeValidation para mensajes inmediatos

## 3. TourFloating.tsx
- **Renderizado**: Ventana flotante del tour con contenido dinámico por step
- **Gestión de Steps**: Diferentes contenidos y botones por paso
- **Auto-close**: Timer automático de 5 segundos en step 3
- **Props**: isVisible, step, onSkip, onContinue, onClose
- **Estado Local**: autoCloseTimer para gestionar cierre automático

## 4. useOnboarding.ts (Hook Principal - ACTUALIZADO)
- **Estado Global**: Gestiona companies, validCompanyCount, tourState
- **Persistencia**: localStorage para tour-shown y draft
- **Validaciones ACTUALIZADAS**: 
  - validateRuc: puede retornar 'error_conexion' para RUCs específicos (20999888777, 20777666555)
  - validateCredentials: puede retornar 'error_conexion' para usuarios específicos (CONEXION01, TIMEOUT07)
  - validateCredentials NO se ejecuta si RUC tiene error_conexion o es inválido
- **Acciones**: addNewCompany, updateCompanyField, validateCompany
- **Tour Logic**: initializeTour, handleTourContinue, handleTourSkip, handleTourClose
- **Timers**: Gestión de setTimeout para validaciones y tour
- **Lógica de Estado**: Prioriza error_conexion > errores de validación > campos incompletos

## 5. validCredentials.json (ACTUALIZADO)
- **RUCs de Prueba para Error de Conexión**:
  - 20999888777: "CONEXIÓN PERDIDA S.A.C." (status: "error_conexion")
  - 20777666555: "TIMEOUT SERVICES EIRL" (status: "error_conexion")
- **Credenciales de Prueba para Error de Conexión**:
  - CONEXION01/ErrorConn123
  - TIMEOUT07/Timeout456
- **Data Source**: RUCs válidos con businessName, status, sunatStatus
- **Credenciales**: Combinaciones válidas de solUser/solPassword
- **Validación**: Fuente de verdad para validateRuc y validateCredentials

## 6. src/index.css (ACTUALIZADO)
- **Colores Orange Agregados**:
  - .bg-orange-50 { background-color: #fff7ed; }
  - .text-orange-500 { color: #f97316; }
  - .text-orange-600 { color: #ea580c; }
  - .border-orange-500 { border-color: #f97316; }
  - .focus\:border-orange-500:focus { border-color: #f97316; }

FLUJOS CRÍTICOS ACTUALIZADOS:
=============================

### A) VALIDACIÓN CON ERROR DE CONEXIÓN EN RUC
1. Usuario ingresa RUC 20999888777 → Validación tiempo real OK (11 dígitos)
2. validateRuc busca en JSON → Encuentra status: "error_conexion"
3. validationState.ruc = 'error_conexion', status = 'error_conexion'
4. businessName se actualiza pero validationState.credentials = null
5. Etiqueta: "En Proceso: Error de conexión en RUC" (naranja)
6. Si credenciales están vacías: + "Incompleto: Credenciales vacías" (amarillo)

### B) VALIDACIÓN CON ERROR DE CONEXIÓN EN CREDENCIALES
1. Usuario ingresa RUC válido → validationState.ruc = 'valid'
2. Usuario completa credenciales CONEXION01/ErrorConn123
3. validateCredentials detecta usuario "CONEXION01" → retorna 'error_conexion'
4. validationState.credentials = 'error_conexion', status = 'error_conexion'
5. Etiquetas múltiples: "Validado: RUC válido" (verde) + "En Proceso: Error de conexión en credenciales" (naranja)
6. Mensaje debajo del input: "Error de conexión en credenciales" (naranja)

### C) RESTRICCIÓN DE VALIDACIÓN DE CREDENCIALES
1. Credenciales SOLO se validan si RUC está en estado 'valid' o 'inactive'
2. Si RUC tiene 'error_conexion', 'invalid', o 'duplicate' → NO se validan credenciales
3. validationState.credentials permanece null hasta que RUC sea válido

### D) RENDERIZADO DE MÚLTIPLES ETIQUETAS
1. getDescriptiveStatusMessages() evalúa estado primero por error_conexion
2. Puede retornar array con múltiples objetos {text, type}
3. Cada etiqueta se renderiza con color específico según type:
   - 'verified': verde
   - 'error': naranja  
   - 'incomplete': amarillo
   - 'invalid': rojo
   - 'validating': azul

### E) PRIORIZACIÓN DE ESTADOS (ACTUALIZADA)
1. Error de conexión (RUC o credenciales) → status = 'error_conexion' 
2. Errores de validación (RUC inválido, credenciales incorrectas) → status = 'no_valido'
3. Campos incompletos sin errores → status = 'incompleto'
4. Todo válido → status = 'verificada' + isValid = true

CASOS DE USO PARA TESTING:
=========================

### ERROR DE CONEXIÓN EN RUC:
- RUC: 20999888777 → Error de conexión + credenciales incompletas
- RUC: 20777666555 → Error de conexión + credenciales incompletas

### ERROR DE CONEXIÓN EN CREDENCIALES:  
- RUC válido (ej: 20123456789) + CONEXION01 + ErrorConn123 → RUC válido + error credenciales
- RUC válido (ej: 20123456789) + TIMEOUT07 + Timeout456 → RUC válido + error credenciales

### VALIDACIÓN NORMAL:
- RUC válido + credenciales correctas → Todo verificado
- RUC inválido → Solo error de RUC
- Campos vacíos → Incompleto